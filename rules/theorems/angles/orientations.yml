to_equality_mod_180:
  inputs:
    - A, B, C, A', B', C': Point
  possible_conclusions:
    - angle(A, B, C) == angle(A', B', C') mod 360 => equal_mod_180(A, B, C, A', B', C')
    - angle(A, B, C) == angle(A', B', C') + 180 mod 360 => equal_mod_180(A, B, C, A', B', C')
    - 2 * angle(A, B, C) == 2 * angle(A', B', C') mod 360 => equal_mod_180(A, B, C, A', B', C')
  trivial_if_equal:
    - [[A, B, C], [A', B', C']]

from_equality_mod_180:
  inputs:
    - A, B, C, A', B', C': Point
  where:
    - equal_mod_180(A, B, C, A', B', C')
  possible_conclusions:
    - orientation(A, B, C) == orientation(A', B', C') mod 360 => angle(A, B, C) == angle(A', B', C') mod 360
    - orientation(A, B, C) == - orientation(A', B', C') mod 360 => angle(A, B, C) == angle(A', B', C') + 180 mod 360

reverse_orientation:
  inputs:
    - A, B, C: Point
  where:
    - not_collinear(A, B, C)
    - exists(orientation(A, B, C))
  conclude:
    - orientation(A, B, C) == - orientation(C, B, A) mod 360
  metadata: auto
