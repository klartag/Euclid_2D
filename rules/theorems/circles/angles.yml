concyclic_sufficient_conditions:
  inputs:
    - A, B, C, D: Point
  where:
    - not_collinear(A, B, C)
  possible_conclusions:
    - angle(A, B, C) == angle(A, D, C) mod 360 => concyclic(A, B, C, D)
    - angle(A, B, C) == angle(A, D, C) + 180 mod 360 => concyclic(A, B, C, D)
  trivial_if_equal:
    - [B, D]
  rank: 5

angles_on_chord:
  inputs:
    - A, B, C, D: Point
    - c: Circle
  where:
    - A, B, C, D in c
    - distinct(A, B, C, D)
  possible_conclusions:
    - orientation(A, C, B) == orientation(A, D, B) mod 360 => angle(A, C, B) == angle(A, D, B) mod 360
    - orientation(A, C, B) == - orientation(A, D, B) mod 360 => angle(A, C, B) == angle(A, D, B) + 180 mod 360
  rank: 4

chords_on_equal_angles:
  inputs:
    - A, B, C, A', B', C': Point
    - c: Circle
  where:
    - A, B, C, A', B', C' in c
  possible_conclusions:
    - angle(A, B, C) == angle(A', B', C') mod 360 => distance(A, C) == distance(A', C')
    - angle(A, B, C) + angle(A', B', C') == 180 mod 360 => distance(A, C) == distance(A', C')
  rank: 4
  trivial_if_equal: 
    - [[A, C], [A', C']]
    - [[A, C], [C', A']]

angles_on_equal_chords:
  inputs:
    - A, B, C, A', B', C': Point
    - c: Circle
  where:
    - A, B, C, A', B', C' in c
    - distinct(A, B, C)
    - distinct(A', B', C')
    # NOTE: Instead of requiring AC == A'C', we require A'C || AC', because it allows us to speak of orientation.
    - parallel(Line(A', C), Line(A, C'))
  possible_conclusions:
    - orientation(A, B, C) == orientation(A', B', C') mod 360 => angle(A, B, C) == angle(A', B', C') mod 360
    - orientation(A, B, C) == - orientation(A', B', C') mod 360 => angle(A, B, C) == angle(A', B', C') + 180 mod 360
  rank: 4
  trivial_if_equal:
    - [[A, C], [A', C']]

angle_to_center:
  inputs:
    - A, B, C: Point
    - c: Circle
  where:
    - A, B, C in c
    - distinct(A, B, C)
    - exists(center(c))
  conclude:
    - 2 * angle(A, B, C) == angle(A, center(c), C) mod 360
  rank: 4
