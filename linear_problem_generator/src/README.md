# TODO: Update the content of this README.

# Linear Search

## Base plan

The basic idea of the linear search is to randomly add objects to the GeoConfig until you get objects that satisfy some interesting predicate.

The improved idea is to create a lot of different objects, among these objects quickly find pairs that are interesting. This should allow increasing the effective depth by a factor of 2.

There are problems that might cause trivial problems to emerge:

1. There may be constructions with unnecessary parts, or that are actually elaborations of a simpler problem.
2. There may be constructions that converge early, then continue the same.

## Problems and solutions

### Unnecessary parts

To solve the unnecessary parts problem, we use trivialized configurations. Trivialized configurations are configurations where some object is initialized using a weaker construction than necessary. If in any such configuration the predicate still holds, then the problem is not primitive, and can be skipped.

### Early convergence

It is possible that the problem relies on some earlier predicate that is proved, and is trivial considering it. Imagine that you construct two points that are actually equal, then proceed with two equivalent symmetric constructions. This would make everything that follows boring.

To solve this, we demand that only the last object satisfies interesting predicates.

## Design

We will have a `GeoConfig` and `ConfigIter` classes in addition to the previous geometry classes.

```rust
struct GeoConfig {
    objects: Vec<&GeoObject>,
    embeds: Vec<&Embed>,
}

impl GeoConfig {
    pub fn child_configs(&self);
}

struct ConfigIter {
    objects: HashMap<GeoObject, Embed>,
    configs: Vec<Vec<GeoConfig>>,
    max_cost: i64,
}
```

The `ConfigIter` stores all objects built and their embeddings, so that we can prune `GeoConfig` while iterating.

### Pruning

There are several reasons to prune GeoConfigs:

* **Containing predicates**. If there are non-trivial predicates satisfied by the GeoConfig, we know it will be killed later, so we might as well kill it now.
* **Not useful**. The last object generated by the GeoConfig at the end of the iteration must be new, and its directed acyclic graph must depend on all other objects in the config. Otherwise, it would also be generated by some other smaller config. We trim the config if it is no longer possible for it to make a unique object in such a way.


## Symmetric Problem Search

One of Bak's criteria for interesting problems was symmetry: If there is some group acting on the problem, then it is likely more interesting.

To find symmetric problems in an intrinsic fashion, we just construct only problems with the given symmetry.
To do this, when searching for a problem, we need:
1. A config storing all the choices we have made.
2. A config storing all the constructions we have made.
3. An object mapping each object x to the list of g*x.

Thus, the SymmetricGeoConfig stores:
1. A short list of objects.
2. A long list of objects.
3. A map from an object to a list of objects.
